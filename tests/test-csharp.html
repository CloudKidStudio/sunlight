<html>

	<head>
		<script type="text/javascript" src="../src/sunlight.js"></script>
		<script type="text/javascript" src="../src/sunlight-csharp.js"></script>
		<link rel="stylesheet" type="text/css" href="../src/sunlight.css" />
	</head>

	<body>
<pre><code id="code" class="sunlight-highlight-csharp">using System;
using UsingAlias = System.Linq.Enumerable;

namespace My.Namespace {
	public abstract class ValueHandlerFactoryBase&lt;in T&gt; : MarshalByRefObject, IValueHandlerFactory, IAmAnInterface where T : IAmATypeConstraint {
		[Obsolete] private Skank foo;
		public const Stripper bar = "foo";
		protected static readonly DirtyWhore baz = 0xffffff;
		
#if NET_20
		private ArrayList list = new ArrayList();
#endif

		[AnAttribute(typeof(Exception), Message = "foo"]
		protected internal class InternalClass&lt;T1, out T2&gt; : ICloneable where T1 : class, IAfterClassConstraint, ISecondConstraint { 
			void Iterate(ICollection&lt;object&gt; foos) {
				foreach (var foo in foos) {
					this.SomeMethod(ref foo, out foo);
				}
			}
		}

		#region verify that casts are properly colored
		partial void Meh() {
			IDisposable foo = (IDisposable)foo as ICloneable;
			foo.Dispose();
			((IDisposable)this).Dispose();
			var lame = typeof(IDisposable);
		}
		#endregion

		/**
		 * Gets or sets the value of an integer
		 * and such. This is a useful comment.
		 */
		public new Object Value {
			get { 
				var get = foo > 0 ? new Integer[foo] : new Integer[0];
				return new List&lt;object&gt; {
					get
				};
			}
			
			set { 
				var set = value;
				value = value;
				value == value ? DoSomething() : DoSomethingElse();
				this.value = set ?? value; 
			}
		}

		private static Func&lt;Object, char&gt; GetFunction(Object o, Character c, Integer[] integers) {
			if (!Object.ReferenceEquals(o, c)) {
				throw new ArgumentException();
			}

			return value => (char)value.GetHashCode();
		}
		
		/// &lt;summary&gt;
		/// Tests the coloring of generic method definitions and
		/// and &lt;c cref="Foo"&gt;generic parameters&lt;/c&gt;
		/// &lt;/summary&gt;
		///
		/// &lt;param name="foos"&gt;Collection of &lt;see cref="Foo" /&gt;&lt;/param&gt;
		[FirstAttribute]
		[Pure(typeof(IDisposable[])), OutOfThisWorld]
		[OutOfThisWorld(AttributeNamedParameter = "foo")]
		[Another]
		Action&lt;IDisposable&gt; DoOtherStuff(IEnumerable&lt;Foo&gt; fooEnumerable, string[] strings) {
			Action&lt;Func&lt;IDisposable, SecondGeneric&gt;&gt; action = () => disposable => new Foo();
			
			//neither foo below should be a named ident
			return foo &lt; 1 || foo &gt; 2;
		}
		
		//method without an access modifier: "Action" should be a named ident
		Action DoStuff() { }

		protected override sealed T NumbersTest&lt;T&gt;(ref Foo foo, out Bar @class, params ArrayOfSomething[] somethings) where T : event, IDisposable, IFoo {
			//let's test out numbers
			int i = 0;
			double d = 1.5;
			float f = (1.7f + 1.2d) * (12 % 5);
			decimal dec = 1.2d;
			int hex = 0x1a; //ooh! hex!

			return default(T);
		}

		public virtual IValueHandler Create(string resourceName, string criterionFieldName) {
			//1) check for resource-specific value handler
			VerifyStuff((int)resourceName);

			/* multi
			line comment
			*/

			var s = "this is \"a\" string";
			s = @"this is ""another""
multi line
string";

			switch (Foo.Bar) {
				case "foo":
					if (2 |= Foo["foo"]) {
						throw new InvalidOperationException(string.Format("fail"));
					}
					break;
				case "bar":
					goto default;
				case Empty:
					return "foo";
				default:
					yield return new GarbanzoBean();
			}
		}
	}
}</code></pre>
	</body>
	<script type="text/javascript"  src="test.js"></script>
	<script type="text/javascript">//<![CDATA[
		assertExists("keyword", "using", "using keyword");
		assertExists("named-ident", "UsingAlias", "using alias");
		assertExists("keyword", "class", "class keyword");
		assertExists("keyword", "in", "in keyword");
		assertExists("keyword", "const", "const keyword");
		assertExists("keyword", "readonly", "readonly keyword");
		assertExists("keyword", "internal", "internal keyword");
		assertExists("keyword", "event", "event keyword");
		assertExists("named-ident", "ValueHandlerFactoryBase", "class name");
		assertExists("named-ident", "MarshalByRefObject", "base class name");
		assertExists("named-ident", "IValueHandlerFactory", "implemented interface");
		assertExists("named-ident", "IAmAnInterface", "implemented interface");
		assertExists("named-ident", "IAmATypeConstraint", "type constraint name");
		assertExists("named-ident", "IAfterClassConstraint", "type constraint name after class");
		assertExists("named-ident", "ISecondConstraint", "second type constraint name after class");
		assertExists("named-ident", "Obsolete", "attribute on field on same line");
		assertExists("named-ident", "Obsolete", "attribute on field on same line");
		assertExists("named-ident", "Object", "Object name");
		assertExists("pragma", "#if NET_20", "pragma");
		assertExists("pragma", "#endregion", "endregion pragma");
		assertExists("ident", "Iterate", "method name");
		assertExists("ident", "Meh", "method name");
		assertExists("ident", "T1", "type param 1");
		assertExists("ident", "T2", "type param 2");
		assertExists("keyword", "set", "set contextual keyword");
		assertExists("ident", "set", "non-keyword set");
		assertExists("keyword", "get", "get contextual keyword");
		assertExists("ident", "get", "non-keyword get");
		assertExists("keyword", "value", "value contextual keyword");
		assertExists("ident", "value", "non-keyword value");
		assertExists("ident", "AttributeNamedParameter", "named parameter in attribute");
		assertExists("named-ident", "Func", "ident before generic return value");
		assertExists("named-ident", "ArgumentException", "class name after new");
		assertExists("named-ident", "Pure", "attribute");
		assertExists("named-ident", "OutOfThisWorld", "attribute");
		assertExists("named-ident", "Another", "attribute");
		assertExists("named-ident", "AnAttribute", "attribute");
		assertExists("named-ident", "FirstAttribute", "attribute");
		assertExists("named-ident", "SecondGeneric", "second generic argument");
		assertExists("ident", "DoStuff", "method name");
		assertExists("ident", "DoOtherStuff", "method name");
		assertExists("ident", "fooEnumerable", "parameter name after generic");
		assertExists("ident", "@class", "@ syntax for idents");
		assertExists("named-ident", "ArrayOfSomething", "class name before []");
		assertExists("ident", "criterionFieldName", "parameter name");
		assertExists("comment", "/* multi\n\t\t\tline comment\n\t\t\t*/", "multi line comment");
		assertExists("named-ident", "GarbanzoBean", "class name");
		assertExists("keyword", "yield return", "yield return");
		assertExists("comment", "//neither foo below should be a named ident", "single line comment");
		assertExists("string", "\"this is \\\"a\\\" string\"", "string with escaped quote");
		assertExists("string", "@\"this is \"\"another\"\"\nmulti line\nstring\"", "verbatim string with escaped quote");
		assertExists("xmlDocCommentMeta", "///", "xml doc comment ///");
		assertExists("xmlDocCommentMeta", "<summary>", "xml doc comment <summary>");
		assertExists("xmlDocCommentMeta", "</summary>", "xml doc comment </summary>");
		assertExists("xmlDocCommentMeta", "<c cref=\"Foo\">", "xml doc comment <c cref>");
		assertExists("xmlDocCommentMeta", "</c>", "xml doc comment <c/c>");
		assertExists("xmlDocCommentContent", "generic parameters", "xml doc comment content between tags");
		assertExists("xmlDocCommentContent", " Tests the coloring of generic method definitions and", "xml doc comment content");
	//]]></script>
</html>