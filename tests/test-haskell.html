<html>

	<head>
		<script type="text/javascript" src="../src/sunlight.js"></script>
		<script type="text/javascript" src="../src/plugins/sunlight-plugin.linenumbers.js"></script>
		<script type="text/javascript" src="../src/lang/sunlight.haskell.js"></script>
		<link rel="stylesheet" type="text/css" href="../src/themes/sunlight.default.css" />
	</head>

	<body>
<pre id="code" class="sunlight-highlight-haskell">---------------------------------------------------------------------
-- SmallCheck: another lightweight testing library.
-- Colin Runciman, August 2006
-- Version 0.2 (November 2006)
--
-- After QuickCheck, by Koen Claessen and John Hughes (2000-2004).
---------------------------------------------------------------------

module SmallCheck (
  smallCheck, depthCheck,
  Property, Testable,
  forAll, forAllElem,
  exists, existsDeeperBy, thereExists, thereExistsElem,
  (==&gt;),
  Series, Serial(..),
  (\/), (&gt;&lt;), two, three, four,
  cons0, cons1, cons2, cons3, cons4,
  alts0, alts1, alts2, alts3, alts4,
  N(..), Nat, Natural,
  depth, inc, dec
  ) where

import Data.List (intersperse)
import Control.Monad (when)
import System.IO (stdout, hFlush)

------------------ &lt;Series of depth-bounded values&gt; -----------------

-- Series arguments should be interpreted as a depth bound (&gt;=0)
-- Series results should have finite length

type Series a = Int -&gt; [a]

-- sum
infixr 7 \/
(\/) :: Series a -&gt; Series a -&gt; Series a
s1 \/ s2 = \d -&gt; s1 d ++ s2 d

-- product
infixr 8 &gt;&lt;
(&gt;&lt;) :: Series a -&gt; Series b -&gt; Series (a,b)
s1 &gt;&lt; s2 = \d -&gt; [(x,y) | x &lt;- s1 d, y &lt;- s2 d]

------------------- &lt;methods for type enumeration&gt; ------------------

-- enumerated data values should be finite and fully defined
-- enumerated functional values should be total and strict

-- bounds:
-- for data values, the depth of nested constructor applications
-- for functional values, both the depth of nested case analysis
-- and the depth of results
 
class Serial a where
  series   :: Series a
  coseries :: Serial b =&gt; Series (a-&gt;b)

instance Serial () where
  series   _ = [()]
  coseries d = [ \() -&gt; b
               | b &lt;- series d ]

instance Serial Int where
  series   d = [(-d)..d]
  coseries d = [ \i -&gt; if i &gt; 0 then f (N (i - 1))
                       else if i &lt; 0 then g (N (abs i - 1))
                       else z
               | z &lt;- alts0 d, f &lt;- alts1 d, g &lt;- alts1 d ]

instance Serial Integer where
  series   d = [ toInteger (i :: Int)
               | i &lt;- series d ]
  coseries d = [ f . (fromInteger :: Integer-&gt;Int)
               | f &lt;- series d ]

newtype N a = N a

instance Show a =&gt; Show (N a) where
  show (N i) = show i

instance (Integral a, Serial a) =&gt; Serial (N a) where
  series   d = map N [0..d']
               where
               d' = fromInteger (toInteger d)
  coseries d = [ \(N i) -&gt; if i &gt; 0 then f (N (i - 1))
                           else z
               | z &lt;- alts0 d, f &lt;- alts1 d ]

type Nat = N Int
type Natural = N Integer

instance Serial Float where
  series d   = [ encodeFloat sig exp
               | (sig,exp) &lt;- series d,
                 odd sig || sig==0 &amp;&amp; exp==0 ]
  coseries d = [ f . decodeFloat
               | f &lt;- series d ]
             
instance Serial Double where
  series   d = [ frac (x :: Float)
               | x &lt;- series d ]
  coseries d = [ f . (frac :: Double-&gt;Float)
               | f &lt;- series d ]

frac :: (Real a, Fractional a, Real b, Fractional b) =&gt; a -&gt; b
frac = fromRational . toRational

instance Serial Char where
  series d   = take (d+1) ['a'..'z']
  coseries d = [ \c -&gt; f (N (fromEnum c - fromEnum 'a'))
               | f &lt;- series d ]

instance (Serial a, Serial b) =&gt;
         Serial (a,b) where
  series   = series &gt;&lt; series
  coseries = map uncurry . coseries

instance (Serial a, Serial b, Serial c) =&gt;
         Serial (a,b,c) where
  series   = \d -&gt; [(a,b,c) | (a,(b,c)) &lt;- series d]
  coseries = map uncurry3 . coseries

instance (Serial a, Serial b, Serial c, Serial d) =&gt;
         Serial (a,b,c,d) where
  series   = \d -&gt; [(a,b,c,d) | (a,(b,(c,d))) &lt;- series d]
  coseries = map uncurry4 . coseries

uncurry3 :: (a-&gt;b-&gt;c-&gt;d) -&gt; ((a,b,c)-&gt;d)
uncurry3 f (x,y,z) = f x y z

uncurry4 :: (a-&gt;b-&gt;c-&gt;d-&gt;e) -&gt; ((a,b,c,d)-&gt;e)
uncurry4 f (w,x,y,z) = f w x y z

two   :: Series a -&gt; Series (a,a)
two   s = s &gt;&lt; s

three :: Series a -&gt; Series (a,a,a)
three s = \d -&gt; [(x,y,z) | (x,(y,z)) &lt;- (s &gt;&lt; s &gt;&lt; s) d]

four  :: Series a -&gt; Series (a,a,a,a)
four  s = \d -&gt; [(w,x,y,z) | (w,(x,(y,z))) &lt;- (s &gt;&lt; s &gt;&lt; s &gt;&lt; s) d]

cons0 :: 
         a -&gt; Series a
cons0 c _ = [c]

cons1 :: Serial a =&gt;
         (a-&gt;b) -&gt; Series b
cons1 c d = [c z | d &gt; 0, z &lt;- series (d-1)]

cons2 :: (Serial a, Serial b) =&gt;
         (a-&gt;b-&gt;c) -&gt; Series c
cons2 c d = [c y z | d &gt; 0, (y,z) &lt;- series (d-1)]

cons3 :: (Serial a, Serial b, Serial c) =&gt;
         (a-&gt;b-&gt;c-&gt;d) -&gt; Series d
cons3 c d = [c x y z | d &gt; 0, (x,y,z) &lt;- series (d-1)]

cons4 :: (Serial a, Serial b, Serial c, Serial d) =&gt;
         (a-&gt;b-&gt;c-&gt;d-&gt;e) -&gt; Series e
cons4 c d = [c w x y z | d &gt; 0, (w,x,y,z) &lt;- series (d-1)]

alts0 ::  Serial a =&gt;
            Series a
alts0 d = series d

alts1 ::  (Serial a, Serial b) =&gt;
            Series (a-&gt;b)
alts1 d = if d &gt; 0 then series (dec d)
          else [\_ -&gt; x | x &lt;- series d]

alts2 ::  (Serial a, Serial b, Serial c) =&gt;
            Series (a-&gt;b-&gt;c)
alts2 d = if d &gt; 0 then series (dec d)
          else [\_ _ -&gt; x | x &lt;- series d]

alts3 ::  (Serial a, Serial b, Serial c, Serial d) =&gt;
            Series (a-&gt;b-&gt;c-&gt;d)
alts3 d = if d &gt; 0 then series (dec d)
          else [\_ _ _ -&gt; x | x &lt;- series d]

alts4 ::  (Serial a, Serial b, Serial c, Serial d, Serial e) =&gt;
            Series (a-&gt;b-&gt;c-&gt;d-&gt;e)
alts4 d = if d &gt; 0 then series (dec d)
          else [\_ _ _ _ -&gt; x | x &lt;- series d]

instance Serial Bool where
  series     = cons0 True \/ cons0 False
  coseries d = [ \x -&gt; if x then b1 else b2
               | (b1,b2) &lt;- series d ]

instance Serial a =&gt; Serial (Maybe a) where
  series     = cons0 Nothing \/ cons1 Just
  coseries d = [ \m -&gt; case m of
                       Nothing -&gt; z
                       Just x  -&gt; f x
               |  z &lt;- alts0 d ,
                  f &lt;- alts1 d ]

instance (Serial a, Serial b) =&gt; Serial (Either a b) where
  series     = cons1 Left \/ cons1 Right
  coseries d = [ \e -&gt; case e of
                       Left x  -&gt; f x
                       Right y -&gt; g y
               |  f &lt;- alts1 d ,
                  g &lt;- alts1 d ]

instance Serial a =&gt; Serial [a] where
  series     = cons0 [] \/ cons2 (:)
  coseries d = [ \xs -&gt; case xs of
                        []      -&gt; y
                        (x:xs') -&gt; f x xs'
               |   y &lt;- alts0 d ,
                   f &lt;- alts2 d ]

-- Warning: the coseries instance here may generate duplicates.
instance (Serial a, Serial b) =&gt; Serial (a-&gt;b) where
  series = coseries
  coseries d = [ \f -&gt; g [f x | x &lt;- series d]
               | g &lt;- series d ]              

-- For customising the depth measure.  Use with care!

depth :: Int -&gt; Int -&gt; Int
depth d d' | d &gt;= 0    = d'+1-d
           | otherwise = error &quot;SmallCheck.depth: argument &lt; 0&quot;

dec :: Int -&gt; Int
dec d | d &gt; 0     = d-1
      | otherwise = error &quot;SmallCheck.dec: argument &lt;= 0&quot;

inc :: Int -&gt; Int
inc d = d+1

-- show the extension of a function (in part, bounded both by
-- the number and depth of arguments)
instance (Serial a, Show a, Show b) =&gt; Show (a-&gt;b) where
  show f = 
    if maxarheight == 1
    &amp;&amp; sumarwidth + length ars * length &quot;-&gt;;&quot; &lt; widthLimit then
      &quot;{&quot;++(
      concat $ intersperse &quot;;&quot; $ [a++&quot;-&gt;&quot;++r | (a,r) &lt;- ars]
      )++&quot;}&quot;
    else
      concat $ [a++&quot;-&gt;\n&quot;++indent r | (a,r) &lt;- ars]
    where
    ars = take lengthLimit [ (show x, show (f x))
                           | x &lt;- series depthLimit ]
    maxarheight = maximum  [ max (height a) (height r)
                           | (a,r) &lt;- ars ]
    sumarwidth = sum       [ length a + length r 
                           | (a,r) &lt;- ars]
    indent = unlines . map (&quot;  &quot;++) . lines
    height = length . lines
    (widthLimit,lengthLimit,depthLimit) = (80,20,3)::(Int,Int,Int)

---------------- &lt;properties and their evaluation&gt; ------------------

-- adapted from QuickCheck originals: here results come in lists,
-- properties have depth arguments, stamps (for classifying random
-- tests) are omitted, existentials are introduced

newtype PR = Prop [Result]

data Result = Result {ok :: Maybe Bool, arguments :: [String]}

nothing :: Result
nothing = Result {ok = Nothing, arguments = []}

result :: Result -&gt; PR
result res = Prop [res]

newtype Property = Property (Int -&gt; PR)

class Testable a where
  property :: a -&gt; Int -&gt; PR

instance Testable Bool where
  property b _ = Prop [Result (Just b) []]

instance Testable PR where
  property prop _ = prop

instance (Serial a, Show a, Testable b) =&gt; Testable (a-&gt;b) where
  property f = f' where Property f' = forAll series f

instance Testable Property where
  property (Property f) d = f d

evaluate :: Testable a =&gt; a -&gt; Series Result
evaluate x d = rs where Prop rs = property x d

forAll :: (Show a, Testable b) =&gt; Series a -&gt; (a-&gt;b) -&gt; Property
forAll xs f = Property $ \d -&gt; Prop $
  [ r{arguments = show x : arguments r}
  | x &lt;- xs d, r &lt;- evaluate (f x) d ]

forAllElem :: (Show a, Testable b) =&gt; [a] -&gt; (a-&gt;b) -&gt; Property
forAllElem xs = forAll (const xs)

thereExists :: Testable b =&gt; Series a -&gt; (a-&gt;b) -&gt; Property
thereExists xs f = Property $ \d -&gt; Prop $
  [ Result
      ( Just $ or [ all pass (evaluate (f x) d)
                  | x &lt;- xs d ] )
      [] ] 
  where
  pass (Result Nothing _)  = True
  pass (Result (Just b) _) = b

thereExistsElem :: Testable b =&gt; [a] -&gt; (a-&gt;b) -&gt; Property
thereExistsElem xs = thereExists (const xs)

exists :: (Serial a, Testable b) =&gt;
            (a-&gt;b) -&gt; Property
exists = thereExists series

existsDeeperBy :: (Serial a, Testable b) =&gt;
                    (Int-&gt;Int) -&gt; (a-&gt;b) -&gt; Property
existsDeeperBy f = thereExists (series . f)
 
infixr 0 ==&gt;

(==&gt;) :: Testable a =&gt; Bool -&gt; a -&gt; Property
True ==&gt;  x = Property (property x)
False ==&gt; x = Property (const (result nothing))

--------------------- &lt;top-level test drivers&gt; ----------------------

-- similar in spirit to QuickCheck but with iterative deepening

-- test for values of depths 0..d stopping when a property
-- fails or when it has been checked for all these values
smallCheck :: Testable a =&gt; Int -&gt; a -&gt; IO String
smallCheck d = iterCheck 0 (Just d)

depthCheck :: Testable a =&gt; Int -&gt; a -&gt; IO String
depthCheck d = iterCheck d (Just d)

iterCheck :: Testable a =&gt; Int -&gt; Maybe Int -&gt; a -&gt; IO String
iterCheck dFrom mdTo t = iter dFrom
  where
  iter :: Int -&gt; IO String
  iter d = do
    let Prop results = property t d
    (ok,s) &lt;- check (mdTo==Nothing) 0 0 True results
    maybe (iter (d+1))
          (\dTo -&gt; if ok &amp;&amp; d &lt; dTo
                        then iter (d+1)
                        else return s)
          mdTo

check :: Bool -&gt; Int -&gt; Int -&gt; Bool -&gt; [Result] -&gt; IO (Bool, String)
check i n x ok rs | null rs = do
  let s = &quot;  Completed &quot;++show n++&quot; test(s)&quot;
      y = if i then &quot;.&quot; else &quot; without failure.&quot;
      z | x &gt; 0     = &quot;  But &quot;++show x++&quot; did not meet ==&gt; condition.&quot;
        | otherwise = &quot;&quot;
  return (ok, s ++ y ++ z)

check i n x ok (Result Nothing _ : rs) = do
  progressReport i n x
  check i (n+1) (x+1) ok rs

check i n x f (Result (Just True) _ : rs) = do
  progressReport i n x
  check i (n+1) x f rs

check i n x f (Result (Just False) args : rs) = do
  let s = &quot;  Failed test no. &quot;++show (n+1)++&quot;. Test values follow.&quot;
      s' = s ++ &quot;: &quot; ++ concat (intersperse &quot;, &quot; args)
  if i then
      check i (n+1) x False rs
    else
      return (False, s')

progressReport :: Bool -&gt; Int -&gt; Int -&gt; IO ()
progressReport _ _ _ = return ()
</pre>
	</body>

	<script type="text/javascript"  src="test.js"></script>
	<script type="text/javascript">//<![CDATA[
		//assertExists("rule", "@import", "css rule declaration");
		
	//]]></script>
</html>