<html>

	<head>
		<script type="text/javascript" src="sunlight.js"></script>
		<script type="text/javascript" src="sunlight-php.js"></script>
		<style type="text/css">
			code {
				font-family: Consolas;
				font-size: 16px;
			}
			.sunlight-keyword, .sunlight-language-construct {
				color: #0000CC;
				text-decoration: none;
			}
			.sunlight-operator {
				color: #000000;
				/*background-color: #000000;*/
			}
			.sunlight-string {
				color: #990000;
			}
			.sunlight-comment {
				color: #009900;
			}
			.sunlight-number {
				color: #CC6600;
			}
			.sunlight-punctuation {
				color: #000000;
			}
			.sunlight-ident {
				color: #000000;
			}
			.sunlight-named-ident, .sunlight-constant {
				color: #2B91AF;
			}
			.sunlight-variable {
				color: #663366;
			}
			.sunlight-function {
				color: #56822E;
				text-decoration: none;
			}
		</style>
	</head>

	<body>
	
	<p>
		If even works&hellip; <code class="sunlight-highlight-php">echo 'Hello World!'</code>&hellip; inline!
	</p>
	
<pre><code class="sunlight-highlight-php">&lt;?php

    /**
     * ProxyBuilder
     *
     * @package   Phroxy
     * @version   1.0
     * @copyright (c) 2010 Tommy Montgomery
     */

    namespace Phroxy;
   
    use ReflectionClass, ReflectionMethod, ReflectionParameter;
   
    /**
     * Class for dynamically building interceptable proxies
     *
     * @package Phroxy
     */
    class ProxyBuilder implements ObjectBuilder {
       
        private $proxyCache = array();
       
        /**
         * The namespace that the proxy is contained within
         *
         * @var string
         */
        const DEFAULT_NAMESPACE = 'Phroxy';
       
        /**
         * Creates an interceptable proxy of the given class
         *
         * @uses   ReflectionCache::getClass()
         * @uses   ReflectionUtil::isProxyable()
         * @param  ReflectionClass $class The class to proxy, must be non-final and instantiable
         * @param  array           $args  Constructor arguments
         * @throws {@link ProxyException} if the class cannot be proxied
         * @return object
         */
        public function build(ReflectionClass $class, array $args = array()) {
            $name = $class-&gt;getName();
            if (!isset($this-&gt;proxyCache[$name])) {
                if (!ReflectionUtil::isProxyable($class)) {
                    throw new ProxyException('The type ' . $name . ' cannot be proxied');
                }
               
                $this-&gt;proxyCache[$name] = $this-&gt;buildProxy($class);
            }
           
            if (!empty($args)) {
                $proxy = ReflectionCache::getClass($this-&gt;proxyCache[$name]);
                return $proxy-&gt;newInstanceArgs($args);
            } else {
                return new $this-&gt;proxyCache[$name]();
            }
        }
       
        /**
         * Generates a unique proxy name for the given class
         *
         * @param  ReflectionClass $class
         * @return string
         */
        protected function generateClassName(ReflectionClass $class) {
            $prefix = 'PhroxyProxy_' . str_replace('\\', '_', $class-&gt;getName());
            do {
                $name = $prefix . '_' . uniqid();
            } while (class_exists(self::DEFAULT_NAMESPACE . '\\' . $name) || interface_exists(self::DEFAULT_NAMESPACE . '\\' . $name));
           
            return $name;
        }
       
        /**
         * Creates a proxy definition and eval()s it
         *
         * @uses   generateClassName()
         * @uses   buildNamespaceDeclaration()
         * @uses   buildClassDefinition()
         * @param  ReflectionClass $class
         * @return string The name of the generated class
         */
        protected final function buildProxy(ReflectionClass $class) {
            $name = $this-&gt;generateClassName($class);
           
            $code = $this-&gt;buildNamespaceDeclaration($class);
            $code .= $this-&gt;buildClassDefinition($class, $name);
           
            eval($code);
           
            return self::DEFAULT_NAMESPACE . '\\' . $name;
        }
       
        /**
         * Builds the code needed for the namespace declaration
         *
         * @param  ReflectionClass $class
         * @return string Literal PHP code
         */
        protected function buildNamespaceDeclaration(ReflectionClass $class) {
            return "namespace Phroxy;\nuse ReflectionMethod, Exception;\n\n";
        }
       
        /**
         * Builds the code needed for a class
         *
         * @uses   buildMethod()
         * @uses   ReflectionUtil::methodIsProxyable()
         * @param  ReflectionClass $class
         * @param  string          $className The name of the proxy
         * @return string Literal PHP code
         */
        protected function buildClassDefinition(ReflectionClass $class, $className) {
            $code = "class $className extends \\" . $class-&gt;getName() . " {\n";
           
            foreach ($class-&gt;getMethods() as $method) {
                if (!ReflectionUtil::methodIsProxyable($method)) {
                    continue;
                }
               
                $code .= $this-&gt;buildMethod($method);
            }
           
            $code .= '}';
            return $code;
        }
       
        /**
         * Builds the code needed for a method
         *
         * @uses   buildMethodParameter()
         * @param  ReflectionMethod $method
         * @return string Literal PHP code
         */
        protected function buildMethod(ReflectionMethod $method) {
            $code = "\t";
            $code .= $method-&gt;isPublic() ? 'public ' : 'protected ';
            $code .= $method-&gt;isStatic() ? 'static ' : '';
            $code .= 'function ';
            if ($method-&gt;returnsReference()) {
                $code .= '&amp;';
            }
            $code .= $method-&gt;getName() . '(';
           
            $params = array();
            $paramVars = array();
            foreach ($method-&gt;getParameters() as $parameter) {
                $params[] = $this-&gt;buildMethodParameter($parameter);
                $paramVars[] = '$' . $parameter-&gt;getName();
            }
           
            do {
                $contextVar = '$context_' . uniqid();
            } while (in_array($contextVar, $paramVars));
           
            do {
                $interceptorsVar = '$interceptors_' . uniqid();
            } while (in_array($interceptorsVar, $paramVars));
           
            $code .= implode(', ', $params) . ") {\n";
            $methodCall = $method-&gt;getName() . '(' . implode(', ', $paramVars) . ')';
           
            $code .= &lt;&lt;&lt;METHODBODY
        $contextVar = new InterceptionContext(isset(\$this) ? \$this : null, new ReflectionMethod(__CLASS__, __FUNCTION__), func_get_args());
        ProxyHandler::interceptBefore($contextVar);

        if ({$contextVar}-&gt;shouldCallNext()) {
            try {
                {$contextVar}-&gt;setReturnValue(parent::$methodCall);
            } catch (Exception \$e) {
                {$contextVar}-&gt;setException(\$e);
            }
        }

        ProxyHandler::interceptAfter($contextVar);
        \$exception = {$contextVar}-&gt;getException();
        if (\$exception !== null) {
            throw \$exception;
        } else {
            return {$contextVar}-&gt;getReturnValue();
        }

METHODBODY;
           
            $code .= "\t}\n";
           
            return $code;
        }
       
        /**
         * Builds the code needed for a method parameter
         *
         * @param  ReflectionParameter $parameter
         * @return string Literal PHP code
         */
        protected final function buildMethodParameter(ReflectionParameter $parameter) {
            $code = '';
            if ($parameter-&gt;isArray()) {
                $code .= 'array';
            } else {
                $class = $parameter-&gt;getClass();
                if ($class instanceof ReflectionClass) {
                    $code .= '\\' . $class-&gt;getName();
                }
            }
           
            $code .= ' ';
            if ($parameter-&gt;isPassedByReference()) {
                $code .= '&amp;';
            }
           
            $code .= '$' . $parameter-&gt;getName();
            if ($parameter-&gt;isOptional()) {
                $code .= ' = ';
                if ($parameter-&gt;isDefaultValueAvailable()) {
                    $code .= var_export($parameter-&gt;getDefaultValue(), true);
                } else {
                    $code .= 'null';
                }
            }
           
            return $code;
        }
       
    }

?&gt;</code></pre>
	</body>

	<script type="text/javascript">//<![CDATA[
		Sunlight.highlightAll();
	//]]></script>
</html>